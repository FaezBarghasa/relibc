//! # Redox C Library (relibc)
//!
//! `relibc` is a portable C standard library (libc) written in Rust. It is designed to be
//! efficient, safe, and clean, providing a viable alternative to existing C libraries like
//! `newlib` or `glibc`, especially for the Redox Operating System.
//!
//! ## Overview
//!
//! The library exposes the standard C API through the functions defined in the [`header`] module.
//! These functions are implemented using platform-specific system calls (backends) or generic
//! algorithms.
//!
//! ## Architecture
//!
//! The project structure is as follows:
//! - **`include/`**: C header files. Some are statically defined, others are generated by `cbindgen`.
//! - **`src/header/`**: Rust implementations of the C headers (e.g., `stdlib`, `unistd`, `stdio`).
//!   Each module corresponds to a standard C header file.
//! - **`src/platform/`**: Platform abstraction layer. This module defines the `Pal` trait and
//!   provides implementations for supported operating systems (Redox, Linux).
//! - **`src/ld_so/`**: The dynamic linker/loader implementation.
//! - **`src/pthread/`**: POSIX threads implementation.
//!
//! ## Supported Platforms
//!
//! - **Redox OS**: The primary target platform.
//! - **Linux**: Supported via the `sc` crate for system calls.
//!
//! ## Feature Flags
//!
//! - **`trace`**: Enables tracing of system calls and other debug information.
//!
//! ## Usage
//!
//! This library is primarily intended to be linked against C programs or Rust programs needing
//! a libc implementation. It can be built as a static library (`librelibc.a`) or a shared
//! object.

#![no_std]
#![allow(warnings)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unused_variables)]
#![feature(alloc_error_handler)]
#![feature(allocator_api)]
#![feature(asm_const)]
#![feature(c_variadic)]
#![feature(core_intrinsics)]
#![feature(macro_derive)]
#![feature(maybe_uninit_slice)]
#![feature(lang_items)]
#![feature(linkage)]
#![feature(pointer_is_aligned_to)]
#![feature(ptr_as_uninit)]
#![feature(slice_as_chunks)]
#![feature(slice_ptr_get)]
#![feature(stmt_expr_attributes)]
#![feature(strict_provenance)]
#![feature(sync_unsafe_cell)]
#![feature(thread_local)]
#![feature(vec_into_raw_parts)]
#![feature(negative_impls)]
#![allow(clippy::cast_lossless)]
#![allow(clippy::cast_ptr_alignment)]
#![allow(clippy::derive_hash_xor_eq)]
#![allow(clippy::eval_order_dependence)]
#![allow(clippy::mut_from_ref)]
// TODO: fix these
#![warn(unaligned_references)]

#[macro_use]
extern crate alloc;
extern crate cbitset;
extern crate memchr;
extern crate posix_regex;
extern crate rand;

#[cfg(target_os = "linux")]
#[macro_use]
extern crate sc;

#[cfg(target_os = "redox")]
extern crate syscall;

#[macro_use]
mod macros;
pub mod c_str;
pub mod c_vec;
pub mod cxa;
pub mod db;
pub mod error;
pub mod fs;
pub mod header;
pub mod io;
pub mod iter;
pub mod ld_so;
pub mod out;
pub mod platform;
pub mod pthread;
pub mod raw_cell;
pub mod start;
pub mod sync;

use crate::platform::{Allocator, NEWALLOCATOR, Pal, Sys};

#[global_allocator]
static ALLOCATOR: Allocator = NEWALLOCATOR;

#[unsafe(no_mangle)]
pub extern "C" fn relibc_panic(pi: &::core::panic::PanicInfo) -> ! {
    use core::fmt::Write;

    let mut w = platform::FileWriter::new(2);
    let _ = w.write_fmt(format_args!("RELIBC PANIC: {}\n", pi));

    core::intrinsics::abort();
}

#[cfg(not(test))]
#[panic_handler]
#[linkage = "weak"]
pub fn rust_begin_unwind(pi: &::core::panic::PanicInfo) -> ! {
    relibc_panic(pi)
}

#[cfg(not(test))]
#[lang = "eh_personality"]
#[linkage = "weak"]
pub extern "C" fn rust_eh_personality() {}

#[cfg(not(test))]
#[alloc_error_handler]
#[linkage = "weak"]
#[unsafe(no_mangle)]
pub extern "C" fn rust_oom(layout: ::core::alloc::Layout) -> ! {
    use core::fmt::Write;

    let mut w = platform::FileWriter::new(2);
    let _ = w.write_fmt(format_args!(
        "RELIBC OOM: {} bytes aligned to {} bytes\n",
        layout.size(),
        layout.align()
    ));

    core::intrinsics::abort();
}

#[cfg(not(test))]
#[allow(non_snake_case)]
#[linkage = "weak"]
#[unsafe(no_mangle)]
pub extern "C" fn _Unwind_Resume() -> ! {
    use core::fmt::Write;

    let mut w = platform::FileWriter::new(2);
    let _ = w.write_str("_Unwind_Resume\n");

    core::intrinsics::abort();
}
