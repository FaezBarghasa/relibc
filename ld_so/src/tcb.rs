// ld_so/src/tcb.rs
//! Thread Control Block and Dynamic TLS Resolution.
//!
//! Implements __tls_get_addr and DTV management.
//! Supports both Static TLS (startup) and Dynamic TLS (dlopen).

use crate::{
    header::elf,
    tls::{TLS_GENERATION, TlsModule, get_tls_module, max_module_id},
};
use alloc::vec::Vec;
use core::{mem, ptr, slice};

/// The argument passed to `__tls_get_addr`.
/// Generated by the compiler for GD (General Dynamic) and LD (Local Dynamic) models.
#[repr(C)]
pub struct TlsIndex {
    /// Module ID (1-based index).
    pub ti_module: usize,
    /// Offset into the module's TLS block.
    pub ti_offset: usize,
}

/// The Dynamic Thread Vector (DTV).
/// Holds pointers to TLS blocks for every module.
#[repr(C)]
pub struct Dtv {
    /// Current capacity (number of modules).
    pub capacity: usize,
    /// The actual vector of pointers.
    /// Conceptually: `dtv[0]` is generation, `dtv[i]` is pointer to module i.
    /// However, the TCB points to `dtv + 1` (or `dtv + 2` depending on implementation).
    /// We maintain a simpler internal structure where `vector[0]` is gen.
    pub vector: *mut usize,
}

pub type Tcb = redox_rt::Tcb;

#[unsafe(no_mangle)]
pub struct TcbExt {
    pub stack_base: *mut (),
    pub stack_size: usize,
    pub tls_dtv: *mut (),
    pub tls_dtv_len: usize,
    pub tls_static_base: *mut (),
}

impl Tcb {
    pub unsafe fn from_static(
        static_tls_ptr: *mut u8,
        static_tls_len: usize,
        static_dtv: *mut (),
        static_dtv_len: usize,
        stack_base: *mut (),
        stack_size: usize,
    ) -> *mut Self {
        let tcb = (static_tls_ptr as *mut Self).offset(-1);
        (*tcb).tcb_ptr = tcb;
        (*tcb).tcb_len = core::mem::size_of::<Self>();
        (*tcb).tls_end = static_tls_ptr.add(static_tls_len);
        (*tcb).dtv = static_dtv;
        (*tcb).dtv_len = static_dtv_len;
        (*tcb).platform_specific.stack_base = stack_base;
        (*tcb).platform_specific.stack_size = stack_size;
        (*tcb).platform_specific.tls_dtv = static_dtv;
        (*tcb).platform_specific.tls_dtv_len = static_dtv_len;
        (*tcb).platform_specific.tls_static_base = static_tls_ptr;
        tcb
    }
}

/// The Runtime Entry Point for Dynamic TLS.
/// Called by code using `__thread` or `thread_local!` when the linker used the GD model.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn __tls_get_addr(ti: *const TlsIndex) -> *mut u8 {
    let mod_id = (*ti).ti_module;
    let offset = (*ti).ti_offset;

    // 1. Get Thread Pointer
    let tcb = Tcb::current().unwrap();
    let dtv = tcb.dtv as *mut elf::TlsDtv;

    // 2. Check Generation (Lazy DTV Update)
    let global_gen = TLS_GENERATION.load(core::sync::atomic::Ordering::Acquire);

    // If DTV is stale or too small for this module ID
    if (*dtv).gen < global_gen || mod_id > (*dtv).num {
        let required = max_module_id().max(mod_id);
        // resize dtv
        let new_dtv_size = (required + 1) * size_of::<elf::TlsModule>();
        let new_dtv = crate::allocator::alloc(new_dtv_size, 16) as *mut elf::TlsDtv;
        (*new_dtv).gen = global_gen;
        (*new_dtv).num = required;
        ptr::copy_nonoverlapping(
            dtv.add(1),
            new_dtv.add(1),
            (*dtv).num * size_of::<elf::TlsModule>(),
        );
        tcb.dtv = new_dtv as *mut ();
        tcb.dtv_len = required;
    }

    // 3. Retrieve Block Pointer
    // dtv.vector[mod_id] holds the pointer.
    let dtv_slot = (dtv as *mut elf::TlsModule).add(mod_id);
    let mut tls_block = (*dtv_slot).pointer as usize;

    // 4. Lazy Allocation
    // If the pointer is 0 (UNALLOCATED), we must allocate it now.
    if tls_block == 0 {
        tls_block = allocate_tls_module(mod_id);
        (*dtv_slot).pointer = tls_block as *mut ();
    }

    // 5. Return Address
    //
    (tls_block as *mut u8).add(offset)
}

/// Allocates and initializes a TLS block for a specific module.
#[inline(never)]
unsafe fn allocate_tls_module(mod_id: usize) -> usize {
    let info = get_tls_module(mod_id).expect("TLS module not registered");

    // If this module is part of the Static TLS set (loaded at startup),
    // we shouldn't be allocating it dynamically unless something went wrong
    // or we are in a thread created *before* this module was loaded (complex case).
    // However, for full dynamic TLS (dlopen), we do this:

    let ptr = crate::__rust_alloc(info.size, info.align);
    if ptr.is_null() {
        core::intrinsics::abort();
    }

    // Initialize .tdata
    if info.image_size > 0 {
        ptr::copy_nonoverlapping(info.image as *const u8, ptr, info.image_size);
    }

    // Zero .tbss
    if info.size > info.image_size {
        ptr::write_bytes(ptr.add(info.image_size), 0, info.size - info.image_size);
    }

    ptr as usize
}
